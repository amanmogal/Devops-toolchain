name: CI/CD Pipeline

on:
  push:
    branches: 
      - main
      - master
  pull_request:
    branches: 
      - main
      - master

env:
  PROJECT_ID: devops-toolchain-456502
  GKE_CLUSTER: devops-toolchain-cluster
  GKE_ZONE: us-central1
  REGISTRY: us-central1-docker.pkg.dev/$PROJECT_ID/devops-toolchain

jobs:
  build-test-deploy:
    name: Build, Test, and Deploy
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    # Authenticate to Google Cloud
    - id: 'auth'
      name: 'Authenticate to Google Cloud'
      uses: 'google-github-actions/auth@v2'
      with:
        credentials_json: '${{ secrets.GCP_SA_KEY }}'
        token_format: 'access_token'
        project_id: 'devops-toolchain-456502'  
        service_account: 'github-actions@devops-toolchain-456502.iam.gserviceaccount.com'

    # Setup gcloud CLI
    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2

    # Install kubectl
    - name: Install kubectl
      run: |
        gcloud components install kubectl
        gcloud components install gke-gcloud-auth-plugin

    # Configure Docker for Artifact Registry
    - name: Configure Docker
      run: |
        gcloud auth configure-docker us-central1-docker.pkg.dev --quiet

    # Check for Dockerfile
    - name: Check Dockerfile exists
      run: |
        if [ ! -f Dockerfile ]; then
          echo "Error: Dockerfile not found"
          exit 1
        fi

    # Build Stage
    - name: Build Docker Image
      run: |
        docker build -t $REGISTRY/app:$GITHUB_SHA . || exit 1
        docker tag $REGISTRY/app:$GITHUB_SHA $REGISTRY/app:latest

    # Test Stage with error handling
    - name: Run Tests
      run: |
        if ! docker run --rm $REGISTRY/app:$GITHUB_SHA npm test; then
          echo "Tests failed"
          exit 1
        fi

    # Security Scan Stage
    - name: Run Security Scan
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: '${{ env.REGISTRY }}/app:${{ github.sha }}'
        format: 'table'
        exit-code: '1'
        ignore-unfixed: true
        severity: 'CRITICAL,HIGH'
      continue-on-error: true

    # Push Image Stage with error handling
    - name: Push Docker Image
      run: |
        if ! docker push $REGISTRY/app:$GITHUB_SHA; then
          echo "Failed to push image"
          exit 1
        fi
        docker push $REGISTRY/app:latest

    # Get GKE Credentials with error handling
    - name: Get GKE Credentials
      run: |
        if ! gcloud container clusters get-credentials $GKE_CLUSTER --region $GKE_ZONE --project $PROJECT_ID; then
          echo "Failed to get cluster credentials"
          exit 1
        fi

    # Deploy to Dev Stage with error handling
    - name: Deploy to Dev
      run: |
        kubectl create namespace dev --dry-run=client -o yaml | kubectl apply -f -
        if ! kubectl apply -k ./k8s/overlays/dev; then
          echo "Failed to apply dev configuration"
          exit 1
        fi
        kubectl set image deployment/app app=$REGISTRY/app:$GITHUB_SHA -n dev
        if ! kubectl rollout status deployment/app -n dev --timeout=300s; then
          echo "Deployment to dev failed"
          kubectl rollout undo deployment/app -n dev
          exit 1
        fi

    # Add SonarQube Analysis with explicit configuration
    - name: Cache SonarQube packages
      uses: actions/cache@v4
      with:
        path: ~\sonar\cache
        key: ${{ runner.os }}-sonar
        restore-keys: ${{ runner.os }}-sonar

    - name: SonarQube Analysis
      uses: SonarSource/sonarqube-scan-action@v4
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      with:
        args: >
          -Dsonar.projectKey=devops-toolchain
          -Dsonar.projectName="DevOps Toolchain"
          -Dsonar.sources=.
          -Dsonar.host.url=${{ secrets.SONAR_HOST_URL }}
          -Dsonar.login=${{ secrets.SONAR_TOKEN }}
          -Dsonar.java.binaries=.
          -Dsonar.exclusions=**/*.pyc,**/*.class,**/node_modules/**,**/dist/**,.git/**,.github/**

    # Optional: Add Quality Gate check
    - name: SonarQube Quality Gate check
      uses: SonarSource/sonarqube-quality-gate-action@v1
      timeout-minutes: 5
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

    # Add Dependency Check
    - name: Dependency Check
      uses: dependency-check/Dependency-Check_Action@main
      with:
        project: 'DevOps-Toolchain'
        path: '.'
        format: 'HTML'

    # Add Metrics Collection
    - name: Export Pipeline Metrics
      run: |
        echo "pipeline_duration_seconds{status=\"${{ job.status }}\"} $SECONDS" >> /tmp/metrics
        curl -X POST http://prometheus-pushgateway:9091/metrics/job/github_actions --data-binary "@/tmp/metrics"

    # Add Test Reporting
    - name: Publish Test Results
      uses: EnricoMi/publish-unit-test-result-action@v2
      if: always()
      with:
        files: "**/test-results/*.xml"

  deploy-prod:
    name: Deploy to Production
    needs: build-test-deploy
    runs-on: ubuntu-latest
    environment: 
      name: production
      url: ${{ steps.get_url.outputs.url }}
    permissions:
      contents: read
      id-token: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    # Authenticate to Google Cloud
    - id: 'auth'
      name: 'Authenticate to Google Cloud'
      uses: 'google-github-actions/auth@v2'
      with:
        credentials_json: '${{ secrets.GCP_SA_KEY }}'
        token_format: 'access_token'

    # Install kubectl
    - name: Install kubectl
      run: |
        gcloud components install kubectl
        gcloud components install gke-gcloud-auth-plugin

    # Get GKE Credentials with error handling
    - name: Get GKE Credentials
      run: |
        if ! gcloud container clusters get-credentials $GKE_CLUSTER --region $GKE_ZONE --project $PROJECT_ID; then
          echo "Failed to get cluster credentials"
          exit 1
        fi

    # Deploy to Prod Stage with error handling and rollback
    - name: Deploy to Production
      run: |
        kubectl create namespace prod --dry-run=client -o yaml | kubectl apply -f -
        if ! kubectl apply -k ./k8s/overlays/prod; then
          echo "Failed to apply prod configuration"
          exit 1
        fi
        OLD_VERSION=$(kubectl get deployment/app -n prod -o=jsonpath='{.spec.template.spec.containers[0].image}')
        echo "OLD_VERSION=$OLD_VERSION" >> $GITHUB_ENV
        
        kubectl set image deployment/app app=$REGISTRY/app:$GITHUB_SHA -n prod
        if ! kubectl rollout status deployment/app -n prod --timeout=300s; then
          echo "Deployment to prod failed, rolling back..."
          kubectl set image deployment/app app=$OLD_VERSION -n prod
          exit 1
        fi

    # Get Service URL
    - name: Get Service URL
      id: get_url
      run: |
        PROD_URL=$(kubectl get service app-service -n prod -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        echo "url=https://${PROD_URL}" >> $GITHUB_OUTPUT
