name: CI/CD Pipeline

on:
  push:
    branches: 
      - main
      - master
  pull_request:
    branches: 
      - main
      - master

env:
  PROJECT_ID: devops-toolchain-456502
  GKE_CLUSTER: devops-toolchain-cluster
  GKE_ZONE: us-central1
  REGISTRY: us-central1-docker.pkg.dev/$PROJECT_ID/devops-toolchain

jobs:
  build-test-deploy:
    name: Build, Test, and Deploy
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
      checks: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    # Authenticate to Google Cloud
    - id: 'auth'
      name: 'Authenticate to Google Cloud'
      uses: 'google-github-actions/auth@v2'
      with:
        credentials_json: '${{ secrets.GCP_SA_KEY }}'
        token_format: 'access_token'
        project_id: 'devops-toolchain-456502'  
        service_account: 'github-actions@devops-toolchain-456502.iam.gserviceaccount.com'

    # Setup gcloud CLI
    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2

    # Install kubectl
    - name: Install kubectl
      run: |
        gcloud components install kubectl
        gcloud components install gke-gcloud-auth-plugin

    # Configure Docker for Artifact Registry
    - name: Configure Docker
      run: |
        gcloud auth configure-docker us-central1-docker.pkg.dev --quiet

    # Check for Dockerfile
    - name: Check Dockerfile exists
      run: |
        if [ ! -f Dockerfile ]; then
          echo "Error: Dockerfile not found"
          exit 1
        fi

    # Build Stage
    - name: Build Docker Image
      run: |
        docker build \
          --build-arg NODE_ENV=production \
          --build-arg PORT=3000 \
          --no-cache \
          -t $REGISTRY/app:$GITHUB_SHA \
          -t $REGISTRY/app:latest \
          .

    # Test Stage with error handling
    - name: Run Tests
      run: |
        echo "Running basic tests..."
        # Test container health
        docker run -d --name test-container $REGISTRY/app:$GITHUB_SHA
        sleep 10
        docker inspect test-container --format='{{.State.Health.Status}}' || exit 1
        docker stop test-container
        docker rm test-container

    # Security Scan Stage
    - name: Run Security Scan
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: '${{ env.REGISTRY }}/app:${{ github.sha }}'
        format: 'table'
        exit-code: '1'
        ignore-unfixed: true
        severity: 'CRITICAL,HIGH'
      continue-on-error: true

    # Push Image Stage with error handling
    - name: Push Docker Image
      run: |
        if ! docker push $REGISTRY/app:$GITHUB_SHA; then
          echo "Failed to push image"
          exit 1
        fi
        docker push $REGISTRY/app:latest

    # Get GKE Credentials with error handling
    - name: Get GKE Credentials
      run: |
        if ! gcloud container clusters get-credentials $GKE_CLUSTER --region $GKE_ZONE --project $PROJECT_ID; then
          echo "Failed to get cluster credentials"
          exit 1
        fi

    # Deploy to Dev Stage
    - name: Deploy to Dev
      run: |
        kubectl create namespace dev --dry-run=client -o yaml | kubectl apply -f -
        cat <<EOF | kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: app
          namespace: dev
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: devops-toolchain
          template:
            metadata:
              labels:
                app: devops-toolchain
            spec:
              containers:
              - name: app
                image: $REGISTRY/app:$GITHUB_SHA
                ports:
                - containerPort: 3000
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: app-service
          namespace: dev
        spec:
          type: ClusterIP
          ports:
          - port: 80
            targetPort: 3000
          selector:
            app: devops-toolchain
        EOF

    # Add SonarQube Analysis with explicit configuration
    - name: Cache SonarQube packages
      uses: actions/cache@v4
      with:
        path: ~\sonar\cache
        key: ${{ runner.os }}-sonar
        restore-keys: ${{ runner.os }}-sonar

    - name: SonarQube Analysis
      uses: SonarSource/sonarqube-scan-action@v4
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      with:
        args: >
          -Dsonar.projectKey=devops-toolchain
          -Dsonar.projectName="DevOps Toolchain"
          -Dsonar.sources=.
          -Dsonar.host.url=${{ secrets.SONAR_HOST_URL }}
          -Dsonar.login=${{ secrets.SONAR_TOKEN }}
          -Dsonar.java.binaries=.
          -Dsonar.exclusions=**/*.pyc,**/*.class,**/node_modules/**,**/dist/**,.git/**,.github/**

    # Optional: Add Quality Gate check
    - name: SonarQube Quality Gate check
      uses: SonarSource/sonarqube-quality-gate-action@v1
      timeout-minutes: 5
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

    # Add Dependency Check
    - name: Dependency Check
      uses: dependency-check/Dependency-Check_Action@main
      with:
        project: 'DevOps-Toolchain'
        path: '.'
        format: 'HTML'

    # Add Metrics Collection
    - name: Export Pipeline Metrics
      run: |
        echo "pipeline_duration_seconds{status=\"${{ job.status }}\"} $SECONDS" >> /tmp/metrics
        curl -X POST http://prometheus-pushgateway:9091/metrics/job/github_actions --data-binary "@/tmp/metrics"

    # Add Test Reporting
    - name: Publish Test Results
      uses: EnricoMi/publish-unit-test-result-action@v2
      if: always()
      with:
        files: "test-results/*.xml"  # Updated path
        check_name: "Test Results"
        comment_mode: off
        github_token: ${{ secrets.GITHUB_TOKEN }}

  deploy-prod:
    name: Deploy to Production
    needs: build-test-deploy
    runs-on: ubuntu-latest
    environment: 
      name: production
      url: ${{ steps.get_url.outputs.url }}
    permissions:
      contents: read
      id-token: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    # Authenticate to Google Cloud
    - id: 'auth'
      name: 'Authenticate to Google Cloud'
      uses: 'google-github-actions/auth@v2'
      with:
        credentials_json: '${{ secrets.GCP_SA_KEY }}'
        token_format: 'access_token'

    # Install kubectl
    - name: Install kubectl
      run: |
        gcloud components install kubectl
        gcloud components install gke-gcloud-auth-plugin

    # Get GKE Credentials with error handling
    - name: Get GKE Credentials
      run: |
        if ! gcloud container clusters get-credentials $GKE_CLUSTER --region $GKE_ZONE --project $PROJECT_ID; then
          echo "Failed to get cluster credentials"
          exit 1
        fi

    # Deploy to Prod Stage
    - name: Deploy to Production
      run: |
        kubectl create namespace prod --dry-run=client -o yaml | kubectl apply -f -
        cat <<EOF | kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: app
          namespace: prod
        spec:
          replicas: 2
          selector:
            matchLabels:
              app: devops-toolchain
          template:
            metadata:
              labels:
                app: devops-toolchain
            spec:
              containers:
              - name: app
                image: $REGISTRY/app:$GITHUB_SHA
                ports:
                - containerPort: 3000
                resources:
                  requests:
                    memory: "128Mi"
                    cpu: "100m"
                  limits:
                    memory: "256Mi"
                    cpu: "200m"
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: app-service
          namespace: prod
        spec:
          type: LoadBalancer
          ports:
          - port: 80
            targetPort: 3000
          selector:
            app: devops-toolchain
        EOF

    # Get Service URL
    - name: Get Service URL
      id: get_url
      run: |
        PROD_URL=$(kubectl get service app-service -n prod -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        echo "url=https://${PROD_URL}" >> $GITHUB_OUTPUT
